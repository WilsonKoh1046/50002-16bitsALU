module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    //output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    //output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    //output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    //output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_seg[8],
    output io_sel[4], 
    input io_button[5],
    input io_dip[3][8]
  ) {
 
  sig rst;
  
  const TIME = 28;
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    .rst(rst) {
      dff register_a[16];
      dff register_b[16];
      dff register_alufn[6];
      dff count[TIME + 1]; 
      fsm state = {
        IDLE, START, MANUAL, CASEP_ADD, CASEP_SUBTRACT1, CASEN_SUBTRACT2, CASE_OVERFLOW_PPNA, CASE_OVERFLOW_NNPA, CASE_OVERFLOW_NPPS, CASE_AND,
        CASE_OR, CASE_XOR, CASE_A, CASE_SHL, CASE_SHR, CASE_SRA, CASE_CMPEQ_T, CASE_CMPEQ_F, CASE_CMPLT_T, CASE_CMPLT_F,
        CASE_CMPLE_T1, CASE_CMPLE_F1, CASE_CMPLE_T2, CASE_MUL1
      };
      
      multi_seven_seg seg; 
    }
  }
  
  sig a[16];
  sig b[16];
  sig alufn[6];
  sig alu[16];
  sig time_hold[TIME + 1];
  
  alu alucall;  
  
  always {
        reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset
      time_hold = count.q - 1;
      
      //led = 8h00;             // turn LEDs off
      //spi_miso = bz;          // not using SPI
      //spi_channel = bzzzz;    // not using flags
      //avr_rx = bz;            // not using serial port
      // Max signed value: ?32,768 to 32,767
      
      //io_led = 3x{{8h00}}; // off my leds
      io_seg = 8hff;  // off my 7 segment displays
      io_sel = 4hf;  // no digits selected
     
      seg.values = {5h0, 5h0, 5h0, 5h0};
      io_sel = ~4h0; 
      a = 8h0;
      b = 8h0;
      
      alufn = io_dip[0][7:2];
      alucall.alufn = alufn;
      alucall.a = a;
      alucall.b = b;
      alu = alucall.alu;
      
      case (state.q) {
        state.START:
          if (io_button[0]){
            state.d = state.CASEP_ADD;}
          if (io_dip[0][0]){
            state.d = state.MANUAL;} 
            
          
        state.MANUAL:
          if(io_dip[0][1]) {  //if input [0][1] is high, set LED strip blocks 1,2 to value of a in 16bits
           a[7:0] = io_dip[1]; 
           a[15:8] = io_dip[2];
           if (io_button[1]) {register_a.d = a; // store 16bit a into register d flip flop 
            } 
            else {
              b[7:0] = io_dip[1]; // else, set LED strip blocks 1,2 to value of b in 16bits
              b[15:8] = io_dip[2];}
              if (io_button[1]) {register_b.d = b;
            }  
          } 
          
          alufn = io_dip[0][7:2]; 
          if(io_button[2]) {
            register_alufn.d = alufn;
            }  
          if(io_button[3]) { // reset values in registers a,b,alufn
            register_a.d = 16b0; 
            register_b.d = 16b0; 
            register_alufn.d = 6b0;
            }
          
          alucall.a = register_a.q;
          alucall.b = register_b.q;
          alucall.alufn = register_alufn.q;
          alu = alucall.alu; 
          if(io_button[3]) {
          state.d =state.START // if button 2 is pressed, go back to start state 
           ;}
         
          
       
        //ADDER TEST CASE 
        state.CASEP_ADD:	        //ADDER Test Case 1(Positive ADD): 12345 + 13461 = 25806
            alucall.alufn = 000000;		//addition operation of ALU
            alucall.a = 0011000000111001; 	//input a = 12345
            alucall.b = 0011010010010101;	//input b = 13461
            alu = alucall.alu; // assign output to alu 
            if (io_dip[2][7]) {
              alu = alu + b1; 
            }
            if (alu == 0110010011001110)  { 	//Expected Output = 25806
              seg.values[3] = 5d10; // A
              seg.values[2] = 5d13; // d
              seg.values[1] = 5d13; // d
              seg.values[0] = 5d01; // 1 
              io_seg=~seg.seg;
              io_sel=~seg.sel;        
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME])) {
              count.d=0; 
              state.d=state.CASEP_SUBTRACT1; }
           
        
        state.CASEP_SUBTRACT1: 		//ADDER Test Case 2(Positive SUB): 25 - 12  = 13 
            alucall.alufn = 000001;		//subtraction operation of ALU
            alucall.a = 1111111111110110;	//input a = 25
            alucall.b = 0000000000001100;	//input b = 12
            alu = alucall.alu;
            if (alu == 0000000000001101) { //Expected Output = 13 
              seg.values[3] = 5d05; // s
              seg.values[2] = 5d03; // u
              seg.values[1] = 5d11; // b
              seg.values[0] = 5d01; // 1 
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
          }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASEN_SUBTRACT2; }
            
  
        
        state.CASEN_SUBTRACT2:		//ADDER Test Case 3(Negative SUB2): -10-(+12) = -22
            alucall.alufn = 000001;		//subtraction operation of ALU
            alucall.a = 1111111111111011;	//input a = -10
            alucall.b = 0000000000001100;	//input b = 12
            alu = alucall.alu;
            if (alu == 1111111111101010) { //Expected Output = -22
              seg.values[3] = 5d05; // s
              seg.values[2] = 5d03; // u
              seg.values[1] = 5d11; // b
              seg.values[0] = 5d22; // 2 
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | count.q[TIME]==1) {
              count.d=0; 
              state.d=state.CASE_OVERFLOW_PPNA;}
        
        
        state.CASE_OVERFLOW_PPNA://ADDER Test Case 4(OFL1): 16384+16384 = -32768 
            alucall.alufn= 000000;		//addition operation of ALU (+ + gives -)
            alucall.a = 0100000000000000;	//input a = 16834
            alucall.b = 0100000000000000;	//input b = 16834
            alu = alucall.alu;
            if (alu == 1000000000000000) { //Expected Output = -32768
              seg.values[3] = 5d06; // p
              seg.values[2] = 5d06; // p
              seg.values[1] = 5d16; // n
              seg.values[0] = 5d10; // A  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME])){
              count.d=0; 
              state.d=state.CASE_OVERFLOW_NNPA; }
            
        
        state.CASE_OVERFLOW_NNPA:	//ADDER Test Case 5(OFL2): -32760 + (-32760) = -65520
            alucall.alufn = 000000;		//addition operation of ALU (- - gives +)
            alucall.a = 1000000000001000;	//input a = -32768
            alucall.b = 1000000000001000;	//input b = -32768
            alu = alucall.alu;
            if (alu == 0000000000010000) { //Expected Output = -65520
              seg.values[3] = 5d16; // n
              seg.values[2] = 5d06; // p
              seg.values[1] = 5d06; // P
              seg.values[0] = 5d10; // A  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
           
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_OVERFLOW_NPPS; }
        
        state.CASE_OVERFLOW_NPPS://ADDER Test Case 5(OFL2): -16384 - (+16384) = -32768
            alucall.alufn = 000001;		//subtraction operation of ALU
            alucall.a = 1100000000000000;	//input a = -16384
            alucall.b = 0100000000000000;	//input b = +16384
            alu = alucall.alu;
            if (alu == 0100000000000000) { //Expected Output = -65520
              seg.values[3] = 5d16; // n
              seg.values[2] = 5d06; // p
              seg.values[1] = 5d06; // P
              seg.values[0] = 5d10; // A  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_AND; }
        
        
        //BOOLEAN TEST CASES
        state.CASE_AND:		//BOOLEAN Test Case (AND) (bitwise comparison)
            alucall.alufn = 011000;		//AND operation of ALU
            alucall.a = 0110101001010111;	//input a
            alucall.b = 1010110001001010;	//input b
            alu = alucall.alu;
            if (io_dip[2][7]) {
              alu = alu + b1; 
            }
            if (alu == 0010100001000010) { // Expected output
              seg.values[3] = 5d10; // A
              seg.values[2] = 5d16; // n
              seg.values[1] = 5d13; // d
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_OR; }
            
        state.CASE_OR:		//BOOLEAN Test Case (OR) (bitwise comparison)
            alucall.alufn = 011110;		//OR operation of ALU
            alucall.a = 0110100001010001;	//input a
            alucall.b = 1010110000101000;	//input b
            alu = alucall.alu;
            if (alu == 1110110001111001) {
              seg.values[3] = 5d00; // o
              seg.values[2] = 5d02; // r
              seg.values[1] = 5d08; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_XOR; }
        
        state.CASE_XOR:	//BOOLEAN Test Case (XOR)
            alucall.alufn = 010110;		//XOR operation of ALU
            alucall.a = 0110100001010111;	//input a
            alucall.b = 1010110010011010;	//input b
            alu = alucall.alu;
            if (alu == 1100010011001101) { // Expected output
              seg.values[3] = 5d17; // X
              seg.values[2] = 5d00; // o
              seg.values[1] = 5d02; // r
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_A; }
        
        state.CASE_A:		//BOOLEAN Test Case (A)
            alucall.alufn = 011010;		//A operation of ALU
            alucall.a = 1010000000011001;	//input a
            alucall.b = 1010110000001000;	//input b
            alu = alucall.alu;
            if (alu == 1010000000011001) {
              seg.values[3] = 5d10; // A
              seg.values[2] = 5d08; // 0
              seg.values[1] = 5d08; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
           
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]| (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_SHL; }
        
        //SHIFTER TEST CASES
        state.CASE_SHL:		//SHIFTER Test Case (SHL)
            alucall.alufn = 100000;		//SHL operation of ALU
            alucall.a = 0100100001101100;	//input a
            alucall.b = 0000000000001000;	//input b (shifting 8 bit)
            alu = alucall.alu;
            if (io_dip[2][7]) {
              alu = alu + b1; 
            }
            if (alu == 0110110000000000) {
              seg.values[3] = 5d05; // S
              seg.values[2] = 5d17; // H
              seg.values[1] = 5d04; // L
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_SHR; }
            
            state.CASE_SHR:		//SHIFTER Test Case (SHR)
            alucall.alufn = 100001;		//SHR operation of ALU
            alucall.a = 0110110011110000;	//input a
            alucall.b = 0000000000000110;	//input b (shifting 8 bit)
            alu = alucall.alu;
            if (alu == 0000000001101100) {
              seg.values[3] = 5d05; // S
              seg.values[2] = 5d17; // H
              seg.values[1] = 5d02; // r
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
          
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_SRA; }
            
        state.CASE_SRA:		//SHIFTER Test Case (SRA)
            alucall.alufn = 100011;		//SRA operation of ALU
            alucall.a = 1100100001100001;	//input a
            alucall.b = 0000000000000100;	//input b (shifting 4 bit)
            alu = alucall.alu;
            if (alu == 1111110010000110) {
              seg.values[3] = 5d05; // S
              seg.values[2] = 5d17; // H
              seg.values[1] = 5d10; // A
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
           
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPEQ_T; }
            
            
        //COMPARATOR TEST CASES
        state.CASE_CMPEQ_T:	//COMPARATOR Test Case 1(CPE1) [5 = 5]
            alucall.alufn = 110011;		//CMPEQ operation of ALU
            alucall.a = 0000000000010101;	//input a = 21
            alucall.b = 0000000000010101;	//input b = 21
            alu = alucall.alu;
            if (io_dip[2][7]) {
              alu = alu + b1; 
            }
            if (alu == 0000000000000001) { // Expected output 
              seg.values[3] = 5d14; // E
              seg.values[2] = 5d01; // 1
              seg.values[1] = 5d08; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPEQ_F; }
            
        state.CASE_CMPEQ_F:	//COMPARATOR Test Case 2(CPE2) [21 = 4]
            alucall.alufn = 110011;		//CMPEQ operation of ALU
            alucall.a = 0000000000010101;	//input a = 21
            alucall.b = 0000000000000100;	//input b = 4
            alu = alucall.alu;
            if (alu == 0000000000000000) { // Expected output
              seg.values[3] = 5d14; // E
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d08; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPLT_T; }
  
        state.CASE_CMPLT_T:	//COMPARATOR Test Case 3(CPL1) [8 < 16]
            alucall.alufn = 110101;		//CMPLT operation of ALU
            alucall.a = 0000000000001000;	//input a = 8
            alucall.b = 0000000000010000;	//input b = 16
            alu = alucall.alu;
            if (alu == 0000000000000001) { // Expected output
              seg.values[3] = 5d04; // L
              seg.values[2] = 5d01; // 1
              seg.values[1] = 5d08; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
          
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPLT_F; }
  
        state.CASE_CMPLT_F://COMPARATOR Test Case 4(CPL2) [6 < -32768]
            alucall.alufn = 110101;		//CMPLT operation of ALU
            alucall.a = 0000000000000110;	//input a = 6
            alucall.b = 1000000000000000;	//input b = -32768
            alu = alucall.alu;
            if (alu == 0000000000000000) { // Expected output
              seg.values[3] = 5d04; // L
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d00; // 0
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPLE_T1; }
            
        state.CASE_CMPLE_T1:	//COMPARATOR Test Case 5 [-32768 <= 16]
            alucall.alufn = 110111;		//CMPLE operation of ALU
            alucall.a = 1000000000000000;	//input a = -32768
            alucall.b = 0000000000010000;	//input b = 16
            alu = alucall.alu;
            if (alu == 0000000000000001) { // Expected output
              seg.values[3] = 5d04; // L
              seg.values[2] = 5d14; // E
              seg.values[1] = 5d01; // 1
              seg.values[0] = 5d01; // 1  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; //0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPLE_F1; }
            
        state.CASE_CMPLE_F1:	//COMPARATOR Test Case 6 [16 <= 3]
            alucall.alufn = 110111;		//CMPLE operation of ALU
            alucall.a = 0000000000010000;	//input a = 16
            alucall.b = 0000000000000011;	//input b = 3
            alu = alucall.alu;
            if (alu == 0000000000000000) { // Expected output
              seg.values[3] = 5d04; // L
              seg.values[2] = 5d14; // E
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; // 0  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; // 0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0]  | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.CASE_CMPLE_T2; }
            
        state.CASE_CMPLE_T2:	//COMPARATOR Test Case 7(
            alucall.alufn = 110111;		//CMPLE operation of ALU [5 = 5]
            alucall.a = 0000000000010000;	//input a = 16
            alucall.b = 0000000000010000;	//input b = 16
            alu = alucall.alu;
            if (alu == 0000000000000001) { // Expected output
              seg.values[3] = 5d04; // L
              seg.values[2] = 5d14; // E
              seg.values[1] = 5d22; // 2
              seg.values[0] = 5d01; // 1  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; // 0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | count.q[TIME]==1) {
              count.d=0; 
              state.d=state.CASE_MUL1; }
            
         //Multiply Test Case // asdfhasdfgasdlfisa where is sybill omg
         state.CASE_MUL1:      //Multiplier Test Case 1
            alucall.alufn = 000010;   //Mul operation of ALU
            alucall.a = 16b0000000000001000;	//input a = 8
            alucall.b = 16b0000000000000011;	//input b = 3
            alu = alucall.alu;
            if (alu == 0000000000011000) { // Expected output 
              seg.values[3] = 5d16; // n
              seg.values[2] = 5d16; // n
              seg.values[1] = 5d03; // u
              seg.values[0] = 5d04; // L  
              io_seg=~seg.seg;
              io_sel=~seg.sel;
            }
            
            else { 
              seg.values[3] = 5d15; // F // error is FFF message
              seg.values[2] = 5d15; // F
              seg.values[1] = 5d15; // F
              seg.values[0] = 5d08; // 0 
              io_seg=~seg.seg;
              io_sel=~seg.sel;  
            }
  
            
            if(io_dip[0][0]) {
              state.d=state.MANUAL;}
              count.d=count.q+1; 
            if(io_button[0] | (count.q[TIME] ^ time_hold[TIME]) ){
              count.d=0; 
              state.d=state.START; }
                  
      }
  
    }
}